<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Operating Systems and Networs SoSe 25 Solutions - 2&nbsp; Blatt 02</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../sh03/03.html" rel="next">
<link href="../sh01/01.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../sh02/02.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Blatt 02</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Operating Systems and Networs SoSe 25 Solutions</a> 
        <div class="sidebar-tools-main">
    <a href="../Operating-Systems-and-Networs-SoSe-25-Solutions.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sh01/01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Blatt 01</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sh02/02.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Blatt 02</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sh03/03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Blatt 03</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sh04/04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Blatt 04</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sh05/05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Blatt 05</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#aufgabe-1" id="toc-aufgabe-1" class="nav-link active" data-scroll-target="#aufgabe-1">Aufgabe 1</a></li>
  <li><a href="#aufgabe-2" id="toc-aufgabe-2" class="nav-link" data-scroll-target="#aufgabe-2">Aufgabe 2</a></li>
  <li><a href="#aufgabe-3" id="toc-aufgabe-3" class="nav-link" data-scroll-target="#aufgabe-3">Aufgabe 3</a>
  <ul class="collapse">
  <li><a href="#erklärung-zur-ausgabe-von-ps--t--h" id="toc-erklärung-zur-ausgabe-von-ps--t--h" class="nav-link" data-scroll-target="#erklärung-zur-ausgabe-von-ps--t--h">Erklärung zur Ausgabe von <code>ps -T -H</code></a></li>
  <li><a href="#process-state-codes" id="toc-process-state-codes" class="nav-link" data-scroll-target="#process-state-codes">Process state Codes</a></li>
  <li><a href="#tiefe-der-aktuellen-sitzung" id="toc-tiefe-der-aktuellen-sitzung" class="nav-link" data-scroll-target="#tiefe-der-aktuellen-sitzung">Tiefe der Aktuellen Sitzung</a></li>
  </ul></li>
  <li><a href="#aufgabe-4" id="toc-aufgabe-4" class="nav-link" data-scroll-target="#aufgabe-4">Aufgabe 4</a></li>
  <li><a href="#aufgabe-5" id="toc-aufgabe-5" class="nav-link" data-scroll-target="#aufgabe-5">Aufgabe 5</a></li>
  <li><a href="#aufgabe-6" id="toc-aufgabe-6" class="nav-link" data-scroll-target="#aufgabe-6">Aufgabe 6</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Blatt 02</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="aufgabe-1" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-1">Aufgabe 1</h2>
<p>Die Datenstruktur <code>task_struct</code> ist im Linux-Kernel-Quellcode (Linux kernel Version <strong>6.15.0</strong>) definiert unter:</p>
<p><a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h"><code>include/linux/sched.h</code></a><br>
Die Definition erstreckt sich über die Zeilen <strong>813 bis 1664</strong>.</p>
<p>Darin befinden sich etwa <strong>320 Member-Variablen</strong>.<br>
Bei einer Annahme von 8 Byte pro Variable ergibt sich eine geschätzte Größe von:</p>
<p><strong>2.560 Byte</strong> <span class="math inline">\(\approx\)</span> <strong>2,5 KB</strong></p>
</section>
<section id="aufgabe-2" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-2">Aufgabe 2</h2>
<p>Der Systemaufruf <code>fork()</code> erzeugt einen neuen Prozess, der eine Kopie des aufrufenden Prozesses ist (Kindprozess).</p>
<p><strong>Rückgabewert:</strong></p>
<ul>
<li><strong>0</strong> im Kindprozess<br>
</li>
<li><strong>PID des Kindes</strong> im Elternprozess<br>
</li>
<li><strong>−1</strong> bei Fehler</li>
</ul>
<ol type="a">
<li><p>Mit dem program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="dt">const</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>fork<span class="op">()</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> i<span class="op">++;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">!=</span> <span class="dv">1</span><span class="op">)</span> fork<span class="op">();</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    fork<span class="op">();</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>werden insgesammt <strong>6</strong> Prozesse erzeugt. Graph der enstehenden Prozess hierarchie:</p>
<pre class="text"><code>P1  
├── P1.1  
│   └── P1.1.1  
│       └── P1.1.1.1  
│   └── P1.1.2  
└── P1.2  </code></pre>
<p>Schrittweise Erzeugung der Prozesse:</p>
<ol type="1">
<li><p><strong>P1</strong> startet das Programm. Der Wert von <code>i</code> ist anfangs <code>0</code>.</p></li>
<li><p>Die erste <code>fork()</code>-Anweisung wird ausgeführt:</p>
<ul>
<li><strong>P1</strong> ist der Elternprozess, der einen neuen Kindprozess <strong>P1.1</strong> erzeugt.</li>
<li>Im Elternprozess (<strong>P1</strong>) ist das Rückgabewert von <code>fork()</code> ≠ 0 → <code>i</code> wird auf <code>1</code> gesetzt.</li>
<li>Im Kindprozess (<strong>P1.1</strong>) ist das Rückgabewert <code>0</code> → <code>i</code> bleibt <code>0</code>.</li>
</ul></li>
<li><p>Danach folgt die Bedingung <code>if (i != 1) fork();</code>:</p>
<ul>
<li><strong>P1</strong> hat <code>i == 1</code> → keine Aktion.</li>
<li><strong>P1.1</strong> hat <code>i == 0</code> → führt eine <code>fork()</code> aus → erzeugt <strong>P1.1.1</strong>.</li>
</ul></li>
<li><p>Schließlich wird eine letzte <code>fork();</code> von <strong>allen existierenden Prozessen</strong> ausgeführt:</p>
<ul>
<li><strong>P1</strong> erzeugt <strong>P1.2</strong></li>
<li><strong>P1.1</strong> erzeugt <strong>P1.1.2</strong></li>
<li><strong>P1.1.1</strong> erzeugt <strong>P1.1.1.1</strong></li>
</ul></li>
</ol>
<!-- ![A2.a) Prozessgraph](./imgs/a2.1-process-tree-no-source.png){width="50%"} --></li>
<li><p>Das Programm führt <code>fork()</code> aus, bis ein Kindprozess mit einer durch 10 teilbaren PID entsteht. Jeder <code>fork()</code> erzeugt ein Kind, das sofort endet (die Rückgabe von <code>fork()</code> is 0 bei einem Kind), außer die Bedingung ist erfüllt. Da etwa jede zehnte PID durch 10 teilbar ist, liegt die <strong>maximale Prozessanzahl</strong> (inkl. Elternprozess) typischerweise bei <strong>etwa 11</strong>.</p>
<p>Da PIDs vom Kernel <strong>in aufsteigender Reihenfolge als nächste freie Zahl</strong> vergeben werden, ist garantiert, dass früher oder später eine durch 10 teilbare PID erzeugt wird. Das Programm terminiert daher immer. Wären PIDs zufällig, könnte es theoretisch unendlich laufen.</p>
<p>Startende oder endende Prozesse können die PID-Vergabe beeinflussen, da sie die Reihenfolge freier PIDs verändern – dadurch variiert die genaue Prozessanzahl je nach Systemzustand.</p></li>
</ol>
</section>
<section id="aufgabe-3" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-3">Aufgabe 3</h2>
<section id="erklärung-zur-ausgabe-von-ps--t--h" class="level3">
<h3 class="anchored" data-anchor-id="erklärung-zur-ausgabe-von-ps--t--h">Erklärung zur Ausgabe von <code>ps -T -H</code></h3>
<p>Das C-Programm:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="dt">const</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>fork<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> sleep<span class="op">(</span><span class="dv">1000</span><span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> exit<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>erzeugt einen Kindprozess. Das Kind beendet sich sofort (<code>exit(0)</code>), während der Elternprozess 1000 Sekunden schläft (<code>sleep(1000)</code>).</p>
<p><strong>Ablauf der Kommandos:</strong></p>
<ol type="1">
<li>Das Ausführen von <code>./test &amp;</code>:
<ul>
<li>Das Programm läuft im Hintergrund.</li>
<li>Die Shell gibt <code>[1] 136620</code> aus → Prozess-ID (PID) 136620.</li>
<li>Der Kindprozess wird erzeugt und terminiert sofort.</li>
<li>Der Elternprozess schläft weiter.</li>
<li>Da <code>wait()</code> <strong>nicht</strong> aufgerufen wird, wird der Kindprozess zu einem <strong>Zombie-Prozess</strong>.</li>
</ul></li>
<li>Das Ausführen von <code>./test</code> und das drücken von <code>&lt;Strg&gt;+Z</code> danach:
<ul>
<li>Das Programm startet im Vordergrund.</li>
<li>Mit <code>&lt;Strg&gt;+Z</code> wird es gestoppt.</li>
<li>Die Shell zeigt: <code>[2]+  Stopped ./test</code>.</li>
<li>Auch hier terminiert der Kindprozess sofort → Zombie-Prozess entsteht erneut.</li>
</ul></li>
</ol>
<p><strong>Ausgabe von <code>ps -T -H</code>:</strong></p>
<pre><code>    PID TTY      STAT   TIME COMMAND
   1025 pts/0    Ss     0:00 /bin/bash --posix
 136620 pts/0    S      0:00   ./test
 136621 pts/0    Z      0:00     [test] &lt;defunct&gt;
 136879 pts/0    T      0:00   ./test
 136880 pts/0    Z      0:00     [test] &lt;defunct&gt;
 136989 pts/0    R+     0:00   ps T -H</code></pre>
<p><strong>Erklärung:</strong></p>
<ul>
<li><code>1025</code>: Die Shell (<code>bash</code>), läuft im Terminal <code>pts/0</code>.</li>
<li><code>136620</code>: Erstes <code>./test</code>-Programm, läuft im Hintergrund, schläft (<code>S</code>).</li>
<li><code>136621</code>: Dessen Kindprozess (Zombie, <code>Z</code>), da <code>exit()</code> aufgerufen wurde, aber vom Elternprozess nicht abgeholt.</li>
<li><code>136879</code>: Zweites <code>./test</code>-Programm, wurde mit <code>&lt;Strg+Z&gt;</code> gestoppt (<code>T</code>).</li>
<li><code>136880</code>: Auch hier: Kindprozess wurde beendet, aber nicht „abgeholt“ → Zombie.</li>
<li><code>136989</code>: Der <code>ps</code>-Prozess selbst, der gerade die Ausgabe erzeugt (<code>R+</code> = laufend im Vordergrund).</li>
</ul>
<p><strong>Die Spalten</strong></p>
<ul>
<li><strong>PID</strong>: Prozess-ID.</li>
<li><strong>TTY</strong>: Terminal, dem der Prozess zugeordnet ist.</li>
<li><strong>STAT</strong>: Prozessstatus:
<ul>
<li><code>S</code>: sleeping – schläft.</li>
<li><code>T</code>: stopped – gestoppt (z. B. durch <code>SIGSTOP</code>).</li>
<li><code>Z</code>: zombie – beendet, aber noch nicht „aufgeräumt“.</li>
<li><code>R</code>: running – aktuell laufend auf der CPU.</li>
<li><code>+</code>: Teil der Vordergrund-Prozessgruppe im Terminal.</li>
</ul></li>
<li><strong>TIME</strong>: CPU-Zeit, die der Prozess verbraucht hat.</li>
<li><strong>COMMAND</strong>: Der auszuführende Befehl.
<ul>
<li><code>[test] &lt;defunct&gt;</code> heißt, es handelt sich um einen Zombie-Prozess, dessen Kommandozeile nicht mehr verfügbar ist.</li>
</ul></li>
</ul>
</section>
<section id="process-state-codes" class="level3">
<h3 class="anchored" data-anchor-id="process-state-codes">Process state Codes</h3>
<p>Prozesszustände (erste Buchstaben):</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 26%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>Code</th>
<th>Meaning</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>R</code></td>
<td>Running</td>
<td>Currently running or ready to run (on CPU)</td>
</tr>
<tr class="even">
<td><code>S</code></td>
<td>Sleeping</td>
<td>Waiting for an event (e.g., input, timer)</td>
</tr>
<tr class="odd">
<td><code>D</code></td>
<td>Uninterruptible sleep</td>
<td>Waiting for I/O (e.g., disk), cannot be killed easily</td>
</tr>
<tr class="even">
<td><code>T</code></td>
<td>Stopped</td>
<td>Process has been stopped (e.g., <code>SIGSTOP</code>, Ctrl+Z)</td>
</tr>
<tr class="odd">
<td><code>Z</code></td>
<td>Zombie</td>
<td>Terminated, but not yet cleaned up by its parent</td>
</tr>
<tr class="even">
<td><code>X</code></td>
<td>Dead</td>
<td>Process is terminated and should be gone (rarely shown)</td>
</tr>
</tbody>
</table>
<p>Zusätzliche flags:</p>
<table class="table">
<thead>
<tr class="header">
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;</code></td>
<td>High priority (not nice to others)</td>
</tr>
<tr class="even">
<td><code>N</code></td>
<td>Low priority (nice value &gt; 0)</td>
</tr>
<tr class="odd">
<td><code>L</code></td>
<td>Has pages locked in memory</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>Session leader</td>
</tr>
<tr class="odd">
<td><code>+</code></td>
<td>In the foreground process group</td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>Multi-threaded (using CLONE_THREAD)</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>In a separate process group</td>
</tr>
</tbody>
</table>
<p>Z.B. <code>Ss+</code> beduetet: Sleeping (S), Session leader (s) &amp; Foreground process (+).</p>
</section>
<section id="tiefe-der-aktuellen-sitzung" class="level3">
<h3 class="anchored" data-anchor-id="tiefe-der-aktuellen-sitzung">Tiefe der Aktuellen Sitzung</h3>
<p>Zuerst finden wir die PID der Aktuellen sitzung mit</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="va">$$</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>heraus. Output: <code>1025</code>.</p>
<p>Danch führen wir das Command <code>ps -eH | less</code> aus und suchen im pager nach “1025”. In unserer Sitzung befand sich “bash” unter der Hierarchie:</p>
<pre><code>1 systemd
    718 ssdm
        766 ssdm-helper
            859 i3
                884 kitty
                    1025 bash</code></pre>
<p>Das entspricht der Tiefe <strong>5</strong> des Prozessbaums.</p>
</section>
</section>
<section id="aufgabe-4" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-4">Aufgabe 4</h2>
<p>Übersicht der Varianten mit Signaturen:</p>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th>Funktion</th>
<th>Signatur</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>execl</code></td>
<td><code>int execl(const char *path, const char *arg0, ..., NULL);</code></td>
</tr>
<tr class="even">
<td><code>execle</code></td>
<td><code>int execle(const char *path, const char *arg0, ..., NULL, char *const envp[]);</code></td>
</tr>
<tr class="odd">
<td><code>execlp</code></td>
<td><code>int execlp(const char *file, const char *arg0, ..., NULL);</code></td>
</tr>
<tr class="even">
<td><code>execv</code></td>
<td><code>int execv(const char *path, char *const argv[]);</code></td>
</tr>
<tr class="odd">
<td><code>execvp</code></td>
<td><code>int execvp(const char *file, char *const argv[]);</code></td>
</tr>
<tr class="even">
<td><code>execvpe</code></td>
<td><code>int execvpe(const char *file, char *const argv[], char *const envp[]);</code></td>
</tr>
<tr class="odd">
<td><code>execve</code></td>
<td><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code></td>
</tr>
</tbody>
</table>
<p>Wichtige Unterschiede:</p>
<ul>
<li><code>l</code> = Argumente als <strong>Liste</strong> (z. B. <code>execl</code>)</li>
<li><code>v</code> = Argumente als <strong>Array (vector)</strong> (z. B. <code>execv</code>)</li>
<li><code>p</code> = <strong>PATH-Suche</strong> aktiv (z. B. <code>execvp</code>)</li>
<li><code>e</code> = <strong>eigene Umgebung (envp[])</strong> möglich (z. B. <code>execle</code>, <code>execvpe</code>)</li>
<li>Kein <code>p</code> = voller Pfad zur Datei nötig</li>
<li>Kein <code>e</code> = aktuelle Umgebungsvariablen werden übernommen</li>
</ul>
<p>Wann welche Variante?</p>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>Variante</th>
<th>Typischer Einsatzzweck</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>execl</code></td>
<td>Fester Pfad und Argumente direkt im Code als Liste</td>
</tr>
<tr class="even">
<td><code>execle</code></td>
<td>Wie <code>execl</code>, aber mit <strong>eigener Umgebung</strong></td>
</tr>
<tr class="odd">
<td><code>execlp</code></td>
<td>Wie <code>execl</code>, aber <strong>PATH-Suche</strong> aktiviert (z. B. <code>ls</code> statt <code>/bin/ls</code>)</td>
</tr>
<tr class="even">
<td><code>execv</code></td>
<td>Pfad bekannt, Argumente liegen <strong>als Array</strong> vor (z. B. aus <code>main</code>)</td>
</tr>
<tr class="odd">
<td><code>execvp</code></td>
<td>Wie <code>execv</code>, aber <strong>mit PATH-Suche</strong> (typisch für Shells)</td>
</tr>
<tr class="even">
<td><code>execvpe</code></td>
<td>Wie <code>execvp</code>, aber mit <strong>eigener Umgebung</strong> (GNU-spezifisch)</td>
</tr>
<tr class="odd">
<td><code>execve</code></td>
<td>Low-Level, <strong>volle Kontrolle</strong> über Pfad, Argumente und Umgebung</td>
</tr>
</tbody>
</table>
</section>
<section id="aufgabe-5" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-5">Aufgabe 5</h2>
<p>Ein Prozesswechsel (Context Switch) tritt auf, wenn das Betriebssystem (OS) die Ausführung eines Prozesses stoppt und zu einem anderen wechselt. Dabei entsteht Overhead, weil:</p>
<ul>
<li>Der aktuelle CPU-Zustand (Register, Programmzähler etc.) gespeichert werden muss</li>
<li>Dieser Zustand im Prozesskontrollblock (PCB) abgelegt wird</li>
<li>Der Zustand des neuen Prozesses aus seinem PCB geladen wird</li>
<li>Die Speicherverwaltungsstrukturen (z. B. Seitentabellen der MMU) aktualisiert werden müssen</li>
<li>Der TLB (Translation Lookaside Buffer) meist ungültig wird und geleert werden muss</li>
<li>Weitere OS-Daten wie Datei-Deskriptoren oder Signale angepasst werden müssen</li>
</ul>
<p>Der PCB enthält:</p>
<ul>
<li>Prozess-ID, Zustand</li>
<li>Register, Programmzähler</li>
<li>Speicherinfos, geöffnete Dateien</li>
<li>Scheduling-Infos</li>
</ul>
<p>Beim Prozesswechsel speichert das OS den PCB des alten Prozesses und lädt den neuen, um eine korrekte Fortsetzung zu ermöglichen. Da jeder Prozess einen eigenen Adressraum besitzt, ist der Aufwand für das Umschalten entsprechend hoch.</p>
<p>Threads desselben Prozesses teilen sich hingegen denselben Adressraum (also denselben Code, Heap, offene Dateien etc.). Das bedeutet:</p>
<ul>
<li>Es ist kein Wechsel des Adressraums nötig</li>
<li>Die MMU- und TLB-Einträge bleiben gültig</li>
<li>Nur der Thread-spezifische Kontext (Register, Stack-Pointer etc.) muss gespeichert werden</li>
</ul>
<p><strong>Fazit:</strong> Ein Threadwechsel ist viel leichter und schneller**, da kein teurer Speicherverwaltungswechsel nötig ist.</p>
</section>
<section id="aufgabe-6" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-6">Aufgabe 6</h2>
<ol type="1">
<li><p>In der ursprünglichen Version werden alle Threads schnell hintereinander gestartet, ohne aufeinander zu warten. Da die Ausführung der Threads vom Scheduler (Betriebssystem) abhängt und parallel erfolgt, kann die Ausgabe beliebig vermischt erscheinen – z. B. kann ein Thread seine Nachricht „number: i“ ausgeben, noch bevor die Hauptfunktion „creating thread i“ gedruckt hat.</p>
<p>In der überarbeiteten Version hingegen wird jeder Thread direkt nach dem Start mit <code>pthread_join</code> wieder eingesammelt. Dadurch läuft immer nur ein Thread zur Zeit, und seine Ausgabe erfolgt vollständig, bevor der nächste beginnt. So entsteht eine streng sequentielle Ausgabe:</p>
<ul>
<li>„creating thread i“</li>
<li>„number: i“</li>
<li>„ending thread i“</li>
</ul>
<p>Diese einfache Struktur vermeidet Race Conditions und benötigt keine zusätzlichen Synchronisationsmechanismen wie Semaphoren oder Locks.</p>
<p>Überarbeitete Version (auch im zip als <code>threads_example.c</code> enthalten):</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>threads_example.c</strong></pre>
</div>
<div class="sourceCode" id="cb7" data-filename="threads_example.c"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp"> </span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_THREADS </span><span class="dv">200000</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> TaskCode <span class="op">(</span><span class="dt">void</span><span class="op">*</span> argument<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> tid <span class="op">=</span> <span class="op">*((</span><span class="dt">int</span><span class="op">*)</span> argument<span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">"number: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> tid<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">"ending thread </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> tid<span class="op">);</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>   pthread_t thread<span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> thread_arg<span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> NUM_THREADS<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      thread_arg <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">"creating thread </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> rc <span class="op">=</span> pthread_create<span class="op">(&amp;</span>thread<span class="op">,</span> NULL<span class="op">,</span> TaskCode<span class="op">,</span> <span class="op">&amp;</span>thread_arg<span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">(</span>rc <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>      rc <span class="op">=</span> pthread_join<span class="op">(</span>thread<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">(</span>rc <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></li>
<li><p>In unserem System <span class="math inline">\(N_{\text{max}} \approx 200000\)</span>.</p></li>
<li><p>Im folgenden Program wird <code>TaskCode()</code> <span class="math inline">\(N_\text{max}\)</span> mal in einer einfachen Schleife aufgerufen:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp"> </span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_THREADS </span><span class="dv">200000</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> TaskCode <span class="op">(</span><span class="dt">void</span><span class="op">*</span> argument<span class="op">)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> tid <span class="op">=</span> <span class="op">*((</span><span class="dt">int</span><span class="op">*)</span> argument<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">"number: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> tid<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">"ending thread </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> tid<span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> NUM_THREADS<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>      TaskCode<span class="op">(&amp;</span>i<span class="op">);</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Die Ausführung dieses Programs dauerte c.&nbsp;2 Sekunden auf unserem System. D.h. die fehlenden zwei <code>pthread_*</code> aufrufe kosten</p>
<ol start="3" type="a">
<li>8 Sekunden für 200000 Schleifen. Das entspricht c.&nbsp;20 millisekunden pro <code>pthread_*</code> Aufruf.</li>
</ol></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../sh01/01.html" class="pagination-link" aria-label="Blatt 01">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Blatt 01</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../sh03/03.html" class="pagination-link" aria-label="Blatt 03">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Blatt 03</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>