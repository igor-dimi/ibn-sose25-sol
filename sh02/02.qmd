---
title: Blatt 02
---


## Aufgabe 1

Die Datenstruktur `task_struct` ist im Linux-Kernel-Quellcode (Linux kernel Version **6.15.0**) definiert unter:

[`include/linux/sched.h`](https://github.com/torvalds/linux/blob/master/include/linux/sched.h)  
Die Definition erstreckt sich über die Zeilen **813 bis 1664**.

Darin befinden sich etwa **320 Member-Variablen**.  
Bei einer Annahme von 8 Byte pro Variable ergibt sich eine geschätzte Größe von:

**2.560 Byte** $\approx$ **2,5 KB**

## Aufgabe 2

Der Systemaufruf `fork()` erzeugt einen neuen Prozess, der eine Kopie des aufrufenden Prozesses ist (Kindprozess).  

**Rückgabewert:**  

* **0** im Kindprozess  
* **PID des Kindes** im Elternprozess  
* **−1** bei Fehler
   
a) Mit dem program:
   
   ```c
   #include <stdio.h>
   
   int main(int argc, char const *argv[])
   {
       int i = 0;
       if (fork() != 0) i++;
       if (i != 1) fork();
       fork();
       return 0;
   }
   ```
   
   werden insgesammt **6** Prozesse erzeugt. Graph der enstehenden Prozess hierarchie:

    ```scss
    P1 (i=1)  
    ├── P1.1 (i=0)  
    │   └── P1.1.1 (i=0)  
    │       └── P1.1.1.1 (i=0)   ← fork() at C  
    │   └── P1.1.2 (i=0)       ← fork() at C  
    └── P1.2 (i=1)           ← fork() at C  
    ```


   
   ![A2.a) Prozessgraph](./imgs/a2.1-process-tree-no-source.png){width="50%"}

b) Das Programm führt `fork()` aus, bis ein Kindprozess mit einer durch 10 teilbaren PID entsteht. Jeder `fork()` erzeugt ein Kind, das sofort endet (die Rückgabe von `fork()` is 0 bei einem Kind), außer die Bedingung ist erfüllt. Da etwa jede zehnte PID durch 10 teilbar ist, liegt die **maximale Prozessanzahl** (inkl. Elternprozess) typischerweise bei **etwa 11**.  

   Da PIDs vom Kernel **in aufsteigender Reihenfolge als nächste freie Zahl** vergeben werden, ist garantiert, dass früher oder später eine durch 10 teilbare PID erzeugt wird. Das Programm terminiert daher immer. Wären PIDs zufällig, könnte es theoretisch unendlich laufen.  
   
   Startende oder endende Prozesse können die PID-Vergabe beeinflussen, da sie die Reihenfolge freier PIDs verändern – dadurch variiert die genaue Prozessanzahl je nach Systemzustand.

## Aufgabe 3

### Erklärung zur Ausgabe von `ps -T -H`

Das C-Programm:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char const *argv[])
{
    if (fork() > 0) sleep(1000);
    else exit(0);
    return 0;
}
```

erzeugt einen Kindprozess. Das Kind beendet sich sofort (`exit(0)`), während der Elternprozess 1000 Sekunden schläft (`sleep(1000)`).


**Ablauf der Kommandos:**

1. Das Ausführen von `./test &`:
   - Das Programm läuft im Hintergrund.
   - Die Shell gibt `[1] 136620` aus → Prozess-ID (PID) 136620.
   - Der Kindprozess wird erzeugt und terminiert sofort.
   - Der Elternprozess schläft weiter.
   - Da `wait()` **nicht** aufgerufen wird, wird der Kindprozess zu einem **Zombie-Prozess**.

2. Das Ausführen von `./test` und das drücken von `<Strg>+Z` danach:
   - Das Programm startet im Vordergrund.
   - Mit `<Strg>+Z` wird es gestoppt.
   - Die Shell zeigt: `[2]+  Stopped ./test`.
   - Auch hier terminiert der Kindprozess sofort → Zombie-Prozess entsteht erneut.


**Ausgabe von `ps -T -H`:**

```
    PID TTY      STAT   TIME COMMAND
   1025 pts/0    Ss     0:00 /bin/bash --posix
 136620 pts/0    S      0:00   ./test
 136621 pts/0    Z      0:00     [test] <defunct>
 136879 pts/0    T      0:00   ./test
 136880 pts/0    Z      0:00     [test] <defunct>
 136989 pts/0    R+     0:00   ps T -H
```

**Erklärung:**

- `1025`: Die Shell (`bash`), läuft im Terminal `pts/0`.
- `136620`: Erstes `./test`-Programm, läuft im Hintergrund, schläft (`S`).
- `136621`: Dessen Kindprozess (Zombie, `Z`), da `exit()` aufgerufen wurde, aber vom Elternprozess nicht abgeholt.
- `136879`: Zweites `./test`-Programm, wurde mit `<Strg+Z>` gestoppt (`T`).
- `136880`: Auch hier: Kindprozess wurde beendet, aber nicht „abgeholt“ → Zombie.
- `136989`: Der `ps`-Prozess selbst, der gerade die Ausgabe erzeugt (`R+` = laufend im Vordergrund).


**Die Spalten**

- **PID**: Prozess-ID.
- **TTY**: Terminal, dem der Prozess zugeordnet ist.
- **STAT**: Prozessstatus:
  - `S`: sleeping – schläft.
  - `T`: stopped – gestoppt (z. B. durch `SIGSTOP`).
  - `Z`: zombie – beendet, aber noch nicht „aufgeräumt“.
  - `R`: running – aktuell laufend auf der CPU.
  - `+`: Teil der Vordergrund-Prozessgruppe im Terminal.
- **TIME**: CPU-Zeit, die der Prozess verbraucht hat.
- **COMMAND**: Der auszuführende Befehl.
  - `[test] <defunct>` heißt, es handelt sich um einen Zombie-Prozess, dessen Kommandozeile nicht mehr verfügbar ist.


### Process state Codes

Prozesszustände (erste Buchstaben):


| Code | Meaning                | Description                                               |
|------|------------------------|-----------------------------------------------------------|
| `R`  | Running                | Currently running or ready to run (on CPU)               |
| `S`  | Sleeping               | Waiting for an event (e.g., input, timer)                |
| `D`  | Uninterruptible sleep  | Waiting for I/O (e.g., disk), cannot be killed easily    |
| `T`  | Stopped                | Process has been stopped (e.g., `SIGSTOP`, Ctrl+Z)       |
| `Z`  | Zombie                 | Terminated, but not yet cleaned up by its parent         |
| `X`  | Dead                   | Process is terminated and should be gone (rarely shown)  |


Zusätzliche flags:


| Flag | Meaning                             |
|------|-------------------------------------|
| `<`  | High priority (not nice to others)  |
| `N`  | Low priority (nice value > 0)       |
| `L`  | Has pages locked in memory          |
| `s`  | Session leader                      |
| `+`  | In the foreground process group     |
| `l`  | Multi-threaded (using CLONE_THREAD) |
| `p`  | In a separate process group         |


Z.B. `Ss+` beduetet: Sleeping (S), Session leader (s) & Foreground process (+).


### Tiefe der Aktuellen Sitzung

Zuerst finden wir die PID der Aktuellen sitzung mit 

```bash
echo $$
```

heraus. Output: `1025`. 

Danch führen wir das Command `ps -eH | less` aus und suchen im pager nach "1025". In unserer Sitzung
befand sich "bash" unter der Hierarchie: 

```
1 systemd
    718 ssdm
        766 ssdm-helper
            859 i3
                884 kitty
                    1025 bash
```

Das entspricht der Tiefe **5** des Prozessbaums. 


