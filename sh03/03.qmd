---
title: Blatt 3
---

## Aufgabe 1

a) Die Ausgabe ist **inkonsistent** – bei mehreren Programmausführungen erscheinen unterschiedliche Werte für `counter`. Dies liegt an einer **Race Condition**, da beide Threads gleichzeitig und ohne Synchronisation auf die gemeinsame Variable `counter` zugreifen. Dadurch können Zwischenergebnisse überschrieben oder verloren gehen, je nachdem, wie der Scheduler die Threads abwechselnd ausführt.


b) Synchronisierte Lösung (Java-Code):

```java
public class Counter {
    static int counter = 0;

    public static class Counter_Thread_A extends Thread {
        public void run() {
            synchronized (Counter.class) {
                counter = 5;
                counter++;
                counter++;
                System.out.println("A-Counter: " + counter);
            }
        }
    }

    public static class Counter_Thread_B extends Thread {
        public void run() {
            synchronized (Counter.class) {
                counter = 6;
                counter++;
                counter++;
                counter++;
                counter++;
                System.out.println("B-Counter: " + counter);
            }
        }
    }

    public static void main(String[] args) {
        Thread a = new Counter_Thread_A();
        Thread b = new Counter_Thread_B();
        a.start();
        b.start();
    }
}
```
Erklärung:

Dieses Programm vermeidet das Race Condition-Problem, indem beide Threads einen `synchronized`-Block verwenden, der auf `Counter.class` synchronisiert ist. Das bedeutet:

* Nur ein Thread darf gleichzeitig den Block betreten.
* Der andere Thread muss warten, bis der erste fertig ist und den Lock freigibt.
* Dadurch wird sichergestellt, dass keine gleichzeitigen Zugriffe auf die gemeinsame Variable `counter` stattfinden.

## Aufgabe 3

a) Unten folgt der Quellcode zur verbesserten Lösung des Producer-Consumer-Problems (`pc2.c`). In dieser Version wird Busy Waiting durch eine effiziente Synchronisation mithilfe eines Mutexes und einer Condition Variable ersetzt.

   Der Code befindet sich auch im beigefügten Zip-Archiv im Ordner `A3`. Dort kann das Programm wie folgt kompiliert und ausgeführt werden:

```bash
make  
./pc2
```

   Diese Implementierung gewährleistet eine korrekte und effiziente Koordination zwischen Producer- und Consumer-Threads:
   
   * Die gemeinsame Warteschlange wird durch einen Mutex geschützt.
   * Threads, die auf eine Bedingung warten, verwenden `pthread_cond_wait()` innerhalb einer `while`-Schleife, um Spurious Wakeups korrekt zu behandeln.
   * Ist die Warteschlange leer, schlafen die Consumer, bis sie ein Signal erhalten; ist sie voll, wartet der Producer entsprechend.
   * Durch das gezielte Aufwecken via `pthread_cond_signal()` oder `pthread_cond_broadcast()` wird unnötiger CPU-Verbrauch durch aktives Warten vermieden.
   
   Insgesamt ist diese Lösung robuster und skalierbarer als die ursprüngliche Variante mit Busy Waiting – insbesondere bei mehreren Consumer-Threads und höherer Auslastung.

```{.c filename="pc2.c"}
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include "mylist.h"

// Mutex to protect access to the shared queue
pthread_mutex_t queue_lock;

// Single condition variable used for both producers and consumers
pthread_cond_t cond_var;

// Shared buffer (a custom linked list acting as a queue)
list_t buffer;

// Counters for task management
int count_proc = 0;
int production_done = 0;

/********************************************************/
/* Function Declarations */

static unsigned long fib(unsigned int n);
static void create_data(elem_t **elem);
static void *consumer_func(void *);
static void *producer_func(void *);

/********************************************************/
/* Compute the nth Fibonacci number (CPU-intensive task) */
static unsigned long fib(unsigned int n)
{
    if (n == 0 || n == 1) {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

/* Allocate and initialize a new task node */
static void create_data(elem_t **elem)
{
    *elem = (elem_t*) malloc(sizeof(elem_t));
    (*elem)->data = FIBONACCI_MAX;
}

/* Consumer thread function */
static void *consumer_func(void *args) 
{
    elem_t *elem;

    while (1) {
        pthread_mutex_lock(&queue_lock);

        // Wait if the queue is empty and production is not yet complete
        while (get_size(&buffer) == 0 && !production_done) {
            pthread_cond_wait(&cond_var, &queue_lock);
        }

        // Exit condition: queue is empty and production has finished
        if (get_size(&buffer) == 0 && production_done) {
            pthread_mutex_unlock(&queue_lock);
            break;
        }

        // Remove an item from the queue
        remove_elem(&buffer, &elem);

        // Wake up a potentially waiting producer
        pthread_cond_signal(&cond_var);

        pthread_mutex_unlock(&queue_lock);

        // Process the task
        fib(elem->data);
        free(elem);
        printf("item consumed\n");
    }

    return NULL;
}

/* Producer thread function */
static void *producer_func(void *args) 
{
    while (1) {
        pthread_mutex_lock(&queue_lock);

        // Wait if the buffer is full
        while (get_size(&buffer) >= MAX_QUEUE_LENGTH) {
            pthread_cond_wait(&cond_var, &queue_lock);
        }

        if (count_proc < MAX_COUNT) {
            // Create and append a new task to the queue
            elem_t *elem;
            create_data(&elem);
            append_elem(&buffer, elem);
            count_proc++;
            printf("item produced\n");

            // Wake up one waiting consumer
            pthread_cond_signal(&cond_var);
        }

        // If production is done, notify all consumers and exit
        if (count_proc >= MAX_COUNT) {
            production_done = 1;

            // Wake up all consumers waiting on cond_var so they can check the exit condition
            pthread_cond_broadcast(&cond_var);

            pthread_mutex_unlock(&queue_lock);
            break;
        }

        pthread_mutex_unlock(&queue_lock);
    }

    return NULL;
}

/* Main function */
int main (int argc, char *argv[])
{
    pthread_t cons_thread[NUM_CONSUMER];
    pthread_t prod_thread;
    int i;

    // Initialize mutex and condition variable
    pthread_mutex_init(&queue_lock, NULL);
    pthread_cond_init(&cond_var, NULL);
    
    init_list(&buffer);

    // Start consumer threads
    for (i = 0; i < NUM_CONSUMER; i++) {
        pthread_create(&cons_thread[i], NULL, &consumer_func, NULL);
    }

    // Start producer thread
    pthread_create(&prod_thread, NULL, &producer_func, NULL);

    // Wait for all consumer threads to finish
    for (i = 0; i < NUM_CONSUMER; i++) {
        pthread_join(cons_thread[i], NULL);
    }

    // Wait for producer thread to finish
    pthread_join(prod_thread, NULL);

    // Cleanup
    pthread_mutex_destroy(&queue_lock);
    pthread_cond_destroy(&cond_var);

    return 0;
}
```
b) 
